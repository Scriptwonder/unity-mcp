using System;
using System.Collections.Generic;
using UnityEngine;

namespace MCPForUnity.Runtime
{
    /// <summary>
    /// Tracks the history of object transformations/replacements.
    /// Attached to the NEW replacement object to maintain a chain of what it replaced.
    /// </summary>
    public class ObjectTransformHistory : MonoBehaviour
    {
        [Serializable]
        public class TransformEntry
        {
            [Tooltip("Reference to the disabled original object")]
            public GameObject sourceObject;

            [Tooltip("Name of the source object at time of transform")]
            public string sourceObjectName;

            [Tooltip("Asset path of the source object's prefab (if any)")]
            public string sourceAssetPath;

            [Tooltip("The prompt/name requested for transformation")]
            public string targetPrompt;

            [Tooltip("Asset path used for the replacement")]
            public string replacementAssetPath;

            [Tooltip("Whether this was generated by Trellis")]
            public bool wasGenerated;

            [Tooltip("Timestamp of the transformation")]
            public string timestamp;

            [Tooltip("Original world position of source")]
            public Vector3 originalPosition;

            [Tooltip("Original world rotation of source")]
            public Quaternion originalRotation;

            [Tooltip("Original local scale of source")]
            public Vector3 originalScale;

            [Tooltip("Original bounds size of source")]
            public Vector3 originalBoundsSize;
        }

        [SerializeField]
        [Tooltip("History of transformations, most recent last")]
        private List<TransformEntry> _history = new List<TransformEntry>();

        /// <summary>
        /// Read-only access to the transformation history.
        /// </summary>
        public IReadOnlyList<TransformEntry> History => _history;

        /// <summary>
        /// The most recent transformation entry, or null if none.
        /// </summary>
        public TransformEntry LatestEntry => _history.Count > 0 ? _history[_history.Count - 1] : null;

        /// <summary>
        /// The original object (first in the chain), or null if none.
        /// </summary>
        public GameObject OriginalObject => _history.Count > 0 ? _history[0].sourceObject : null;

        /// <summary>
        /// Records a new transformation in the history.
        /// </summary>
        public void RecordTransform(
            GameObject sourceObject,
            string targetPrompt,
            string replacementAssetPath,
            bool wasGenerated,
            Vector3 originalPosition,
            Quaternion originalRotation,
            Vector3 originalScale,
            Vector3 originalBoundsSize,
            string sourceAssetPath = null)
        {
            var entry = new TransformEntry
            {
                sourceObject = sourceObject,
                sourceObjectName = sourceObject != null ? sourceObject.name : "Unknown",
                sourceAssetPath = sourceAssetPath ?? "",
                targetPrompt = targetPrompt,
                replacementAssetPath = replacementAssetPath,
                wasGenerated = wasGenerated,
                timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
                originalPosition = originalPosition,
                originalRotation = originalRotation,
                originalScale = originalScale,
                originalBoundsSize = originalBoundsSize
            };

            _history.Add(entry);
        }

        /// <summary>
        /// Copies history from another ObjectTransformHistory (for chained transforms).
        /// </summary>
        public void CopyHistoryFrom(ObjectTransformHistory other)
        {
            if (other == null || other._history == null) return;

            foreach (var entry in other._history)
            {
                _history.Add(entry);
            }
        }

        /// <summary>
        /// Reverts to the previous state (re-enables the last source object, destroys this object).
        /// </summary>
        /// <returns>The re-enabled previous object, or null if no history.</returns>
        public GameObject RevertToPrevious()
        {
            if (_history.Count == 0)
            {
                Debug.LogWarning($"[ObjectTransformHistory] No history to revert on '{gameObject.name}'");
                return null;
            }

            var lastEntry = _history[_history.Count - 1];
            if (lastEntry.sourceObject == null)
            {
                Debug.LogError($"[ObjectTransformHistory] Previous source object reference is missing on '{gameObject.name}'");
                return null;
            }

            // Re-enable the previous object
            lastEntry.sourceObject.SetActive(true);

            // Restore its original transform
            lastEntry.sourceObject.transform.position = lastEntry.originalPosition;
            lastEntry.sourceObject.transform.rotation = lastEntry.originalRotation;
            lastEntry.sourceObject.transform.localScale = lastEntry.originalScale;

            var revertedObject = lastEntry.sourceObject;

            // Destroy this replacement object
            if (Application.isPlaying)
            {
                Destroy(gameObject);
            }
            else
            {
#if UNITY_EDITOR
                UnityEditor.Undo.DestroyObjectImmediate(gameObject);
#else
                DestroyImmediate(gameObject);
#endif
            }

            return revertedObject;
        }

        /// <summary>
        /// Reverts to the original object (first in the chain), destroying all intermediate objects.
        /// </summary>
        /// <returns>The re-enabled original object, or null if no history.</returns>
        public GameObject RevertToOriginal()
        {
            if (_history.Count == 0)
            {
                Debug.LogWarning($"[ObjectTransformHistory] No history to revert on '{gameObject.name}'");
                return null;
            }

            var firstEntry = _history[0];
            if (firstEntry.sourceObject == null)
            {
                Debug.LogError($"[ObjectTransformHistory] Original source object reference is missing on '{gameObject.name}'");
                return null;
            }

            // Destroy all intermediate disabled objects (except the original)
            for (int i = 1; i < _history.Count; i++)
            {
                if (_history[i].sourceObject != null)
                {
                    if (Application.isPlaying)
                    {
                        Destroy(_history[i].sourceObject);
                    }
                    else
                    {
#if UNITY_EDITOR
                        UnityEditor.Undo.DestroyObjectImmediate(_history[i].sourceObject);
#else
                        DestroyImmediate(_history[i].sourceObject);
#endif
                    }
                }
            }

            // Re-enable the original object
            firstEntry.sourceObject.SetActive(true);

            // Restore its original transform
            firstEntry.sourceObject.transform.position = firstEntry.originalPosition;
            firstEntry.sourceObject.transform.rotation = firstEntry.originalRotation;
            firstEntry.sourceObject.transform.localScale = firstEntry.originalScale;

            var originalObject = firstEntry.sourceObject;

            // Destroy this replacement object
            if (Application.isPlaying)
            {
                Destroy(gameObject);
            }
            else
            {
#if UNITY_EDITOR
                UnityEditor.Undo.DestroyObjectImmediate(gameObject);
#else
                DestroyImmediate(gameObject);
#endif
            }

            return originalObject;
        }

        /// <summary>
        /// Gets a summary of the transformation history for debugging/display.
        /// </summary>
        public string GetHistorySummary()
        {
            if (_history.Count == 0)
                return "No transformation history.";

            var summary = new System.Text.StringBuilder();
            summary.AppendLine($"Transformation History ({_history.Count} entries):");

            for (int i = 0; i < _history.Count; i++)
            {
                var entry = _history[i];
                var status = entry.sourceObject != null ? 
                    (entry.sourceObject.activeInHierarchy ? "Active" : "Disabled") : 
                    "Missing";
                
                summary.AppendLine($"  [{i}] '{entry.sourceObjectName}' â†’ '{entry.targetPrompt}' " +
                    $"({(entry.wasGenerated ? "Generated" : "Existing")}) [{status}] @ {entry.timestamp}");
            }

            return summary.ToString();
        }
    }
}
